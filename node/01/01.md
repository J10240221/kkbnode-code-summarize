# node lesson 1

## async 错误处理

- 【待验证】async 函数比 promise,和回调函数 对于 异常的处理 更为高级，友好，在函数最外层的 try 可以捕获内部所有的异常，而 promise 则需要在每个 promise 最后的 then 后面加，callback 也是要单独处理

```js
// 1 在 a 或 b 或 c 任何的错误 都可以通过一个 try捕获
try {
  const a = await a(b(c()));
} catch (err) {}


// 2
promiseApi.then().catch();

// 3
a(() => {
  try{
     //...some code
  }catch(){}
})
```

- ✨✨ 解答：没错 async 的错误处理 更高级，那是因为 async 内部是 通过 generator 实现的，javascript 是单线程的，只有一个函数调用栈，所以运行在 此函数调用栈上的 回调函数 或者 promise 如果发生错误，之前的函数调用栈 早就清空了，没办法 获取，而 generator 协程 则有自己单独的 调用栈，所以 可以支持更高级的异常的捕获
  - (es6 一文中有写到： 由于 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。)

## node 中的 progress.argv

- progress 就是当前执行的 node 进程， argv 则是当前被执行的 命令行的 后面的 参数

## 介绍 实现 约定路由的 功能，

### 受此启发：

- 命令行交互实现 一个业务对象的 配置代码 自动生成!!! (避免编写配置文件时很多配置 不知道意思，只能看代码的窘境，完成提效)
